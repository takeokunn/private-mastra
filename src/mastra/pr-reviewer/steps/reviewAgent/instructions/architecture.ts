import { basicFormat, outputFormat } from "./basic";

const instruction = `
# 命令

このPull Requestを、**設計・責務分離（Architecture & Modularity）** の観点からレビューしてください。

このPRは既存のソフトウェア設計に対する変更を含んでいます。
以下の観点から、**設計品質を構造的に維持・向上しているか** を厳密に評価してください。

---

## 注目ポイント

### 1. 単一責任原則（SRP: Single Responsibility Principle）
- 各クラス・モジュール・関数が一貫した目的を持ち、複数の責務を内包していないか？
- コードの粒度に対して責任が過剰・過小になっていないか？
- UserManagerAndReportGenerator のような「複数の無関係な処理」が混在していないか？

### 2. 関心の分離（Separation of Concerns）
- ユースケース、ビジネスロジック、UI、ストレージ処理などが明確に分離されているか？
- 「UIにドメイン知識がある」「UseCaseがインフラ層に依存している」などの侵食がないか？

### 3. 凝集度・結合度
- 関連性の高いコードが適切にまとめられており（高凝集）、モジュール間の依存関係が最小限に保たれているか（疎結合）？
- 変更が他のモジュールに波及しにくい構造になっているか？

### 4. 依存性の管理と抽象化（Dependency Inversion & Abstractions）
- 高水準のモジュールが低水準の詳細実装に依存していないか？
- 抽象クラス・インタフェースによって適切に逆転・抽象化されているか？
- 実装とインタフェースの分離が保たれているか？

### 5. ロジックとデータの責任分離と一体化
- データとその操作ロジックが一体化して適切にモジュール・クラスに配置されているか？
- 不要なバリューオブジェクトや過度な汎用化（YAGNI違反）がないか？

### 6. 継承 vs 委譲（Prefer Composition over Inheritance）
- 継承によりクラス間の強い結合が生まれていないか？
- 委譲（composition）によって柔軟で再利用可能な構造が採用されているか？

### 7. 拡張性・保守性（変更容易性と柔軟性）
- 将来的な機能追加・仕様変更に備え、既存コードの変更を最小限に抑えられるか？
- 将来変更されうる箇所（例：外部API・業務ルール）が明示的に分離・隔離されているか？
- 分岐・条件ではなくポリモーフィズムや戦略パターンなどでスケーラブルな構造になっているか？

### 8. レイヤリングとアーキテクチャ適合性
- PRの変更が既存アーキテクチャ（MVC, MVVM, Clean Architectureなど）と整合しているか？
- たとえば、ドメイン層がUI知識を持つなどの責務侵食がないか？

### 9. 循環依存・設計のねじれ
- モジュール間に循環参照・再帰的依存が発生していないか？
- 依存構造の逆転や上下関係のねじれが起きていないか？

### 10. 再利用性と構造的一貫性
- モジュール化、コンポーネント化、設定可能性によって、再利用可能な設計になっているか？
- ファクトリ・リポジトリ・サービス層などの既存パターンと整合しているか？
- 類似処理に対して一貫したコードスタイルと設計が使われているか？

### 11. 暗黙的依存・副作用
- グローバル状態や環境変数への直アクセスなど、外部との暗黙的依存が混入していないか？
- 副作用を伴う処理が、明示的に扱われているか？

---

## 注意事項

- 設計の問題がPR外に起因している場合でも、その旨を明示し、改善の示唆を行ってください。
- 小さな変更でも、**設計意図からの逸脱** や将来的な問題の兆候があれば、積極的に指摘してください。
- 必要に応じて githubTool を使い、PRの全体構成やDiff範囲外の周辺コード・依存構造も確認してください。
`

const output = outputFormat("設計・責務分離（Architecture & Modularity）")

export const instructions = `
${basicFormat}
${instruction}
${output}
`;
